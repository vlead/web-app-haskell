#+TITLE: App


* Introduction

Controllers for handling the following routes :

** addUser

   - URL :: /addUser

   - Method :: POST

   - Data Params ::
     {
      'email': '<value>',
      'name': '<value>',
      'roles' : <value>
     }

   - Success Response ::
     + Code: 200

     + Content:
       #+BEGIN_EXAMPLE
       {
         "email": {
         "email": "xyz@gmail.com",
         "id": "2"
          },
       "id": "2",
       "name": {
       "id": "2",
       "name": "xyz"
          },
       "roles": [
             {
            "id": "2",
            "name": "user"
             }
           ]
       }
       
       #+END_EXAMPLE

** showUser


  - URL :: /showUsers
  - Method :: GET

  - URL Params ::  None
       
  - Success Response ::
    + Code: 200

    + Content ::
      #+BEGIN_EXAMPLE
      [
	{
	  "id": "1",
	  "email": {
	    "email": "xyz@vlabs.ac.in",
	    "id": "1"
	  },
	  "roles": [],
	  "name": {
	    "name": "admin",
	    "id": "1"
	  }
	},
	{
	  "id": "2",
	  "email": {
	    "email": "abc@gmail.com",
	    "id": "2"
	  },
	  "roles": [],
	  "name": {
	    "name": "abc",
	    "id": "2"
	  }
	}
      ]
      #+END_EXAMPLE
* Language Extensions and Imports

#+NAME: extns_and_imports
#+BEGIN_SRC haskell
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
{-# LANGUAGE TypeOperators     #-}

module App where

import           Control.Monad.IO.Class
import           Control.Monad.Logger (runStderrLoggingT)

import           Data.String.Conversions

import           Database.Persist
import           Database.Persist.Sql
import           Database.Persist.Sqlite

import           Network.Wai
import           Network.Wai.Handler.Warp as Warp

import           Servant

import           Data.Text

import           Api
import           Models

#+END_SRC

* Server handlers

#+NAME: server
#+BEGIN_SRC haskell
server :: ConnectionPool -> Server UserAPI
server pool =
  showUsersHandler
  :<|> addUserHandler
  :<|> deleteUserHandler
  where
    showUsersHandler = liftIO $ showAllUsersHelper pool 
    addUserHandler newUser = liftIO $ addUserHelper pool newUser
    deleteUserHandler userToDel = liftIO $ deleteUserHelper pool userToDel


-- function that takes the server function and returns a WAI application 
app :: ConnectionPool -> Application
app pool = serve userAPI $ server pool
  where
    userAPI :: Proxy UserAPI
    userAPI = Proxy


-- to integrate Persist backend with API
-- createSqlitePool creates a pool of database connections
mkApp :: FilePath -> IO Application
mkApp sqliteFile = do
  pool <- runStderrLoggingT $ do
    createSqlitePool (cs sqliteFile) 5

  runSqlPool (runMigration migrateAll) pool
  return $ app pool


-- to run the SQL database
run :: FilePath -> IO ()
run sqliteFile =
  Warp.run 8000 =<< mkApp sqliteFile


#+END_SRC
* Controllers

#+NAME: controllers
#+BEGIN_SRC haskell 

-- helper function for showUsersHandler
--showAllUsers :: ConnectionPool -> IO ([Maybe User])
showAllUsersHelper pool = flip runSqlPersistMPool pool $ do
  users <- selectList [] []
  return $ Prelude.map entityVal users

-- here we assume that there are non-zero users in the database


addUserHelper :: ConnectionPool -> User -> IO (Maybe (Key (User)))
addUserHelper pool newUser = flip runSqlPersistMPool pool $ do
  exists <- selectFirst [UserName ==. (userName newUser)] []
  case exists of
    Nothing -> Just <$> insert newUser
    Just _  -> return Nothing

  
-- note: <$> is the infix symbol for =fmap=
-- note: using Prelude.map to avoid confusion with Data.Text.Map 
-- note: DB actions are IO actions, and will therefore return a value of IO ()
-- and therefore we need to use liftIO () to raise it to the Handler monad
-- this is where monad transformations come in
  

#+END_SRC

* Error Handlers
* Tangling

#+NAME: tangling
#+BEGIN_SRC haskell :eval no :noweb yes :tangle App.hs
<<extns_and_imports>>
<<controllers>>
<<server>>
#+END_SRC
