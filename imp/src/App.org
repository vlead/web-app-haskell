#+TITLE: App


* Introduction

Controllers for handling the following routes :

** addUser

   - URL :: /addUser

   - Method :: POST

   - Data Params ::
     {
      'name': '<value>',
      'email': '<value>',
     }

   - Success Response ::
     + <userId>

** showUser


  - URL :: /showUsers
  - Method :: GET

  - URL Params ::  None
       
  - Success Response ::
   
    + Content ::
      #+BEGIN_EXAMPLE
  [
	{
        email: "abc@xyz.com",
        roles:
            role: "NonAdmin"
        name: "Abc Def"
    }
  ]  
      #+END_EXAMPLE
** deleteUser

   - URL :: /deleteUser

   - 
* Language Extensions and Imports
  
#+NAME: extns_and_imports
#+BEGIN_SRC haskell
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
{-# LANGUAGE TypeOperators     #-}

module App where

import           Control.Monad.IO.Class
import           Control.Monad.Logger (runStderrLoggingT)

import           Data.String.Conversions

import           Database.Persist
import           Database.Persist.Sql
import           Database.Persist.Sqlite

import           Network.Wai
import           Network.Wai.Handler.Warp as Warp

import           Servant

import           Data.Text

import           Api
import           Models
import           Role

#+END_SRC

* Converting To And From Route Datatypes

** =UserData= to =User=
#+NAME: from_userdata_to_user
#+BEGIN_SRC haskell
toUserDatatype :: UserData -> User
toUserDatatype (UserData userDataName userDataEmail) = User {userName=userDataName,  userEmail=userDataEmail, userRoles=NonAdmin}
#+END_SRC
** =UniqueUserData= to =Text=

#+NAME: from_uniqueuserdata_to_text
#+BEGIN_SRC haskell

toTextDatatype :: UniqueUserData -> Text
toTextDatatype (UniqueUserData userData) = pack(userData)

#+END_SRC
* Server handlers

#+NAME: server
#+BEGIN_SRC haskell
server :: ConnectionPool -> Server UserAPI
server pool =
  showUsersHandler
  :<|> addUserHandler
  :<|> deleteUserHandler
  where
    showUsersHandler = liftIO $ showAllUsersHelper pool 
    addUserHandler newUser = liftIO $ addUserHelper pool $ toUserDatatype newUser
    deleteUserHandler userToDel = liftIO $ deleteUserHelper pool $ toTextDatatype userToDel


-- function that takes the server function and returns a WAI application 
app :: ConnectionPool -> Application
app pool = serve userAPI $ server pool
  where
    userAPI :: Proxy UserAPI
    userAPI = Proxy


-- to integrate Persist backend with API
-- createSqlitePool creates a pool of database connections
mkApp :: FilePath -> IO Application
mkApp sqliteFile = do
  pool <- runStderrLoggingT $ do
    createSqlitePool (cs sqliteFile) 5

  runSqlPool (runMigration migrateAll) pool
  return $ app pool


-- to run the SQL database
run :: FilePath -> IO ()
run sqliteFile = 
  Warp.run 8000 =<< mkApp sqliteFile
      


#+END_SRC
* Controllers

#+NAME: controllers
#+BEGIN_SRC haskell 

-- helper function for showUsersHandler
--showAllUsers :: ConnectionPool -> IO ([Maybe User])
showAllUsersHelper pool = flip runSqlPersistMPool pool $ do
  users <- selectList [] []
  return $ Prelude.map entityVal users

-- here we assume that there are non-zero users in the database


-- helper function for addUserHandler
--addUserHelper :: ConnectionPool -> User -> IO (Maybe (Key (User)))
addUserHelper pool newUser = flip runSqlPersistMPool pool $ do
  exists <- selectFirst [UserName ==. (userName newUser)] []
  case exists of
    Nothing -> Just <$> insert newUser
    Just _  -> return Nothing


-- helper function for deleteUserHandler
deleteUserHelper :: ConnectionPool -> Text -> IO ((Maybe (User)))
deleteUserHelper pool userToDel = flip runSqlPersistMPool pool $ do
  deletedUser <- selectFirst [UserEmail ==. unpack(userToDel)] []
  case deletedUser of
    Nothing -> return Nothing
    Just _ -> do 
                 userIfDeleted <- deleteWhere [UserEmail ==. unpack(userToDel)]
                 return $ entityVal <$> deletedUser 
  
#+END_SRC
  
-- note: <$> is the infix symbol for =fmap=
-- note: using Prelude.map to avoid confusion with Data.Text.Map 
-- note: DB actions are IO actions, and will therefore return a value of IO ()
-- and therefore we need to use liftIO () to raise it to the Handler monad
-- this is where monad transformations come in
  
* Admin User Invariant

Admin user invariants include :

  - The system must have a single user with =roles = Admin=.
  - The system cannot have less than one user.
    
#+NAME: admin_user_invariant
#+BEGIN_SRC haskell

-- to check if admin user exists
adminUserCheck :: ConnectionPool -> IO(String)
adminUserCheck pool = flip runSqlPersistMPool pool $ do
  adminUser <- selectFirst [UserRoles ==. Admin] []
  case adminUser of
    Nothing -> do
      adminUserId <- insert $ User "admin-user" "admin@email.com" $ Admin
      return "Admin User Added"
    Just _ -> return "Admin User Exists"
    

#+END_SRC
* Tangling

#+NAME: tangling
#+BEGIN_SRC haskell :eval no :noweb yes :tangle App.hs
<<extns_and_imports>>
<<from_userdata_to_user>>
<<from_uniqueuserdata_to_text>>
<<controllers>>
<<admin_user_invariant>>
<<server>>
#+END_SRC
