#+TITLE: Authentication Function for App


* Introduction

Authentication is implemented using sessions and cookie-based authentication.

** Session

A value of type =Session= is stored in the database for each user logged in.

=Session= type has the following properties :

  - SessionUserEmail :: Email of the logged-in user
  - SessionUserRoles  :: Role of the logged-in user
  - SessionId        :: Id of the session, which is passed as a cookie to the client.


** Login

A value of type =Session= is created and stored in the database upon login. A
cookie corresponding to the newly-created session is sent to the client.
** Logout

The session corresponding to the logged-in user is deleted from the database
upon logout.
** Initialisation

Upon initialisation, all sessions in the database are deleted, if any.
** Authentication

For routes that need authentication, a value of type =Int= - that corresponds
to the =SessionId= of the current session- is passed as header.

*** Admin Auth

    - Usage :: Used to verify if logged-in user has role admin.
    - Procedure :: check if session with =SessionId = authVal= has role
                   =Admin=.
    - Function :: =adminAuthCheck=
    
*** Login Auth

    - Usage :: Used to verify if user is logged in.
    - Procedure :: check if session with =SessionId = authVal= exists in the
                   database.
    - Function :: =authCheck=
* Language Extensions and Imports
  
#+NAME: extns_and_imports
#+BEGIN_SRC haskell
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
{-# LANGUAGE TypeOperators     #-}

module Authentication where

import           Control.Monad.IO.Class
import           Control.Monad.Logger (runStderrLoggingT)

import           Data.String.Conversions
import qualified Data.ByteString.Lazy.Char8 as B           

import           Database.Persist
import           Database.Persist.Sql
import           Database.Persist.Sqlite

import           Network.Wai
import           Network.Wai.Handler.Warp as Warp

import           Servant

import           Data.Text

import           Api
import           Models
import           Role

#+END_SRC

* Authentication Handlers

#+NAME: auth_handlers
#+BEGIN_SRC haskell
-- All authentication-related values are prefixed with auth-


-- | To return sessionId value if header exists
-- | and return 0 if header does not exist
headerCheck :: Maybe String -> String
headerCheck authVal = case authVal of
    Nothing -> "0"
    Just value -> value
    

-- | To return True if user is logged in
-- | and False if user is not logged in
loginCheck :: ConnectionPool -> String -> IO Bool
loginCheck pool authSessionId = flip runSqlPersistMPool pool $ do
  isLoggedIn <- get $ SessionKey $ read authSessionId
  case isLoggedIn of
    Nothing -> return False
    Just _ -> return True

    
-- | To return False if user is NonAdmin user
-- | And True if user is Admin user
adminAuthCheck :: ConnectionPool -> String -> IO Bool
adminAuthCheck pool authSessionId = flip runSqlPersistMPool pool $ do
  roleOfLoggedInUser <- get $ SessionKey $ read authSessionId
  case roleOfLoggedInUser of
    Nothing -> return False
    Just roleValue -> case (sessionUserRoles roleValue) of 
                        NonAdmin -> return False
                        Admin    -> return True


#+END_SRC
* Tangling

#+NAME: tangling
#+BEGIN_SRC haskell :eval no :noweb yes :tangle Authentication.hs
<<extns_and_imports>>
<<auth_handlers>>
#+END_SRC
