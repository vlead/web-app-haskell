<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-06-29 Thu 15:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dependency Parser in Haskell</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Atreyee" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Dependency Parser in Haskell</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org987588f">1. Imports</a></li>
<li><a href="#org0c5c11e">2. Introduction</a></li>
<li><a href="#org3642967">3. Example Latin Lexicon And Grammar</a>
<ul>
<li><a href="#org3b23d5a">3.1. Lexicon</a></li>
<li><a href="#org292910d">3.2. Grammar</a></li>
</ul>
</li>
<li><a href="#org11d26e3">4. Example English Lexicon and Grammar</a>
<ul>
<li><a href="#org8e19655">4.1. Lexicon</a></li>
<li><a href="#org4d00f52">4.2. Grammar</a></li>
</ul>
</li>
<li><a href="#orgb6e8887">5. Family of Closure Functions</a></li>
<li><a href="#orgaa402e5">6. Data Structures</a></li>
<li><a href="#org876f9c3">7. Basic Operators For Constructing a Parse</a></li>
<li><a href="#org5abaaf7">8. Extracting Information From Node</a>
<ul>
<li><a href="#org3039039">8.1. Extracting Word Information From Node</a></li>
<li><a href="#orgbc93297">8.2. Extracting Neighbouring Nodes From Node</a></li>
<li><a href="#orgcc88829">8.3. Extracting Head And Dependents Of Node</a></li>
</ul>
</li>
<li><a href="#org8f72b1c">9. Higher-Level Interface Functions</a>
<ul>
<li><a href="#orga5333f8">9.1. For Computing Related Nodes</a></li>
<li><a href="#orgbdcf198">9.2. For Computing Arc Roles</a></li>
<li><a href="#org8accf9b">9.3. For Finding Relations of a Specific Type</a></li>
<li><a href="#org22b787c">9.4. Other Useful Functions</a></li>
</ul>
</li>
<li><a href="#orgad4828c">10. Parser Core</a>
<ul>
<li><a href="#org5246c33">10.1. Shift Function</a></li>
<li><a href="#orgf236185">10.2. Helper Functions for Connect</a></li>
<li><a href="#orgfbe3dac">10.3. Connect Function</a></li>
<li><a href="#orgd813f34">10.4. Step function</a></li>
<li><a href="#org1c173f7">10.5. <code>steps</code> and <code>parser</code> functions</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org987588f" class="outline-2">
<h2 id="org987588f"><span class="section-number-2">1</span> Imports</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">
<pre class="src src-haskell">
import Control.Monad

</pre>
</div>
</div>
</div>


<div id="outline-container-org0c5c11e" class="outline-2">
<h2 id="org0c5c11e"><span class="section-number-2">2</span> Introduction</h2>
<div class="outline-text-2" id="text-2">
<p>
Here, we demonstrate the building of a dependency parser structure using
Haskell. This is an implementation of the parser engine shown in <a href="http://ltrc.iiit.ac.in/icon2016/proceedings/icon2016/pdf/W16-6310.pdf">this paper</a>
by Tomasz Obrebski.
</p>

<p>
The parser is structured into two parts- a language-agnostic parser core, where
minimal assumptions are made about structural properties of the syntactic trees
allowed and the nature of grammatical constraints. The parser engine takes a
lexicon and a grammar - represented using structures native to Haskell - and
outputs a dependency structure.
</p>
</div>
</div>


<div id="outline-container-org3642967" class="outline-2">
<h2 id="org3642967"><span class="section-number-2">3</span> Example Latin Lexicon And Grammar</h2>
<div class="outline-text-2" id="text-3">
<p>
The parser takes a <code>lexicon</code> and <code>grammar</code> as input.
</p>
</div>

<div id="outline-container-org3b23d5a" class="outline-3">
<h3 id="org3b23d5a"><span class="section-number-3">3.1</span> Lexicon</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The lexicon for a small subset of Latin sentences is defined below.
</p>

<p>
The lexicon consists of :
</p>

<dl class="org-dl">
<dt>Nouns</dt><dd>Joannes, Mariam</dd>
<dt>Verbs</dt><dd>Amat</dd>
</dl>

<div class="org-src-container">
<pre class="src src-haskell">
data Category = Nn | Na | V deriving (Eq, Ord)

data Role = Subj | Cmpl deriving (Eq, Ord)

instance Show Role where
  show Subj = "Subj"
  show Cmpl = "Cmpl"

instance Show Category where
  show Nn = "Nn"
  show Na = "Na"
  show V  = "V"

dic "Joannes" = [Nn]
dic "Mariam"  = [Na]
dic "Amat"    = [V]

</pre>
</div>
</div>
</div>

<div id="outline-container-org292910d" class="outline-3">
<h3 id="org292910d"><span class="section-number-3">3.2</span> Grammar</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Here, we build a simple, minimal grammar. The grammar consists of three
head-dependent links:
</p>

<ul class="org-ul">
<li>a <code>Verb</code> is head of <code>Noun-Nominative</code> and</li>
</ul>
<p>
<code>Noun-Accusative</code>
</p>
<ul class="org-ul">
<li>Any other syntactic relationships - such as <code>Nn -&gt; Na</code> - do not form an arc
in the tree</li>
</ul>

<p>
Here, we make no assumptions about the presence or absence of head-uniqueness
in the grammer. Therefore, it is possible for a dependent to have multiple
heads. (Of course, the grammar presented above does not allow for this
possibility, but nevertheless that is a feature of the grammar and not the
parser engine)
</p>

<div class="org-src-container">
<pre class="src src-haskell">
-- to connect a dependent to its heads
heads d = [ (r, h) | h &lt;- preds d,
                     r &lt;- link (getCategory h) (getCategory d)]


-- to connect a head to its dependents
deps h = [ (r, d) | d &lt;- (leftmost . (leftDep `mappend` pure) &gt;=&gt; preds $ h),
                    r &lt;- link (getCategory h) (getCategory d)]       

-- to show the role of an arc
link V Nn = [Subj]
link V Na = [Cmpl]
link _ _  = []

pass = const True
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org11d26e3" class="outline-2">
<h2 id="org11d26e3"><span class="section-number-2">4</span> Example English Lexicon and Grammar</h2>
<div class="outline-text-2" id="text-4">
<p>
The author of the paper gives examples of lexicons featuring small subsets of
Latin and Polish. Here, we build a lexicon featuring a small subset of English,
talking about people and cats.
</p>
</div>

<div id="outline-container-org8e19655" class="outline-3">
<h3 id="org8e19655"><span class="section-number-3">4.1</span> Lexicon</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">
<pre class="src src-haskell">

data Category = Nn | Na | V | Dt deriving (Eq, Ord)

data Role = Subj | Cmpl | Det deriving (Eq, Ord)

instance Show Role where
  show Subj = "Subj"
  show Cmpl = "Cmpl"
  show Det  = "Det"

instance Show Category where
  show Nn = "Nn"
  show Na = "Na"
  show V  = "V"
  show Dt = "Dt"


-- nominative nouns
dic "I" = [Nn]
dic "You" = [Nn]
dic "We" = [Nn]
dic "She" = [Nn]
dic "He" = [Nn]
dic "They" = [Nn]

-- accusative nouns
dic "cat" = [Na]
dic "cats" = [Na]

-- determiners
dic "a" = [Dt]
dic "the" = [Dt]

-- verbs
dic "owns" = [V]
dic "own" = [V]
dic "feed" = [V]
dic "fed" = [V]

-- links
link Na Dt = [Det]
link V Nn = [Subj]
link V Na = [Cmpl]
link _ _ = []
</pre>
</div>
</div>
</div>
<div id="outline-container-org4d00f52" class="outline-3">
<h3 id="org4d00f52"><span class="section-number-3">4.2</span> Grammar</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">
<pre class="src src-haskell">

-- to connect a dependent to its heads
heads d = [ (r, h) | h &lt;- preds d,
                     r &lt;- link (getCategory h) (getCategory d)]


-- to connect a head to its dependents
deps h = [ (r, d) | d &lt;- (leftmost . (leftDep `mappend` pure) &gt;=&gt; preds $ h),
                    r &lt;- link (getCategory h) (getCategory d)]       


pass = const True
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb6e8887" class="outline-2">
<h2 id="orgb6e8887"><span class="section-number-2">5</span> Family of Closure Functions</h2>
<div class="outline-text-2" id="text-5">
<p>
Defining the family of closure functions that will be used in the parser.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
clo, mclo, rclo, mrclo :: (a -&gt; [a]) -&gt; a -&gt; [a]
clo f = f &gt;=&gt; (pure `mappend` clo f)
rclo f = pure `mappend` clo f
mclo f = f &gt;=&gt; mrclo f
mrclo f x = let
              fx = f x in
                 if null fx
                 then pure x
                 else fx &gt;&gt;= mrclo f

</pre>
</div>
</div>
</div>


<div id="outline-container-orgaa402e5" class="outline-2">
<h2 id="orgaa402e5"><span class="section-number-2">6</span> Data Structures</h2>
<div class="outline-text-2" id="text-6">
<p>
The parser core is based on the following data types:
</p>

<dl class="org-dl">
<dt><code>Parse</code></dt><dd>A (partial/full) parse is represented as a sequence of parse
steps. Each step consumes one word and introduces a new node to the parse.</dd>

<dt><code>Step</code></dt><dd>A parse is a sequence (represented as a <code>List</code>) of parse steps. A
step is a type representing an action - it takes in a word and adds a node
to the tree. Therefore, a <code>Step</code> type takes the following arguments:

<ul class="org-ul">
<li><code>index</code> : the index of the word (i.e: it's position within a sentence)</li>
<li><code>category</code> : the syntactic category of the node (word)</li>
<li><code>headArc</code> : the arc linking the node to its left head. This arc is
present only if the node is preceded by its head in the surface ordering.</li>
<li><code>depArcs</code> : the list of arcs connecting the node with its left dependents</li>
</ul></dd>
</dl>

<p>
It is noted that the presence of both a left-head arc and left-dependents
ensure that each word in a sentence is connected to the tree.
</p>

<dl class="org-dl">
<dt><code>Node</code></dt><dd>A node of the tree. Contains the entire parse from the node's
perspective - for a node <code>i</code>, <code>history</code> contains all the steps from <code>1</code> to
<code>i</code>, and <code>future</code> contains all the steps from <code>i+1</code> to the last step.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-haskell">
type Index = Int

type Arc = (Role, Index)

data Step = Step {
                 index :: Index,
                 category :: Category,
                 headArc :: [Arc],
                 depArcs :: [Arc]
                 } deriving (Eq, Ord, Show)


type Parse = [Step]

data Node = Node {
                 history :: [Step],
                 future :: [Step]
                 } deriving (Eq, Ord)


</pre>
</div>
</div>
</div>



<div id="outline-container-org876f9c3" class="outline-2">
<h2 id="org876f9c3"><span class="section-number-2">7</span> Basic Operators For Constructing a Parse</h2>
<div class="outline-text-2" id="text-7">
<p>
We introduce three basic operators for constructing a parse:
</p>

<dl class="org-dl">
<dt>(&lt;&lt;)</dt><dd>Adds an unconnected node with index <code>i</code> and category <code>c</code> to the
parse <code>p</code></dd>
<dt>(+-&gt;)</dt><dd>adds the current node as dependent of the node <code>i</code>, with role <code>r</code></dd>
<dt>(+&lt;-)</dt><dd>adds the current node as head of the node <code>i</code>, with role <code>r</code></dd>
</dl>

<div class="org-src-container">
<pre class="src src-haskell">
infixl 4 &lt;&lt;, +-&gt;, +&lt;-
  
(&lt;&lt;) :: Parse -&gt; (Index, Category) -&gt; Parse
p &lt;&lt; (i, c) = Step i c [] [] : p

(+-&gt;),(+&lt;-) :: Parse -&gt; (Role, Index) -&gt; Parse
(Step i c [] d:p) +-&gt; (r, j) = Step i c [(r, j)] d:p
(Step i c h d:p)  +&lt;- (r, j) = Step i c h ((r,j) : d) : p


</pre>
</div>
</div>
</div>


<div id="outline-container-org5abaaf7" class="outline-2">
<h2 id="org5abaaf7"><span class="section-number-2">8</span> Extracting Information From Node</h2>
<div class="outline-text-2" id="text-8">
<p>
Each node contains the full information about the parse. Given this,
information often needs to be extracted from a Node, such as index/category of
word, predecessor or successor nodes, etc. Here, we define some helper
functions to extract information from a Node.
</p>
</div>


<div id="outline-container-org3039039" class="outline-3">
<h3 id="org3039039"><span class="section-number-3">8.1</span> Extracting Word Information From Node</h3>
<div class="outline-text-3" id="text-8-1">
<p>
To extract the index of a word from a node :
</p>

<div class="org-src-container">
<pre class="src src-haskell">
getIndex :: Node -&gt; Index
getIndex (Node (Step index category headArc depArcs : _) _) = index

</pre>
</div>


<p>
To extract the category of a word from a node :
</p>

<div class="org-src-container">
<pre class="src src-haskell">
getCategory :: Node -&gt; Category
getCategory (Node (Step index category headArc depArcs : _) _) = category

</pre>
</div>


<p>
To extract the list of left-head arcs from a node :
</p>

<div class="org-src-container">
<pre class="src src-haskell">
getHeadArc :: Node -&gt; [Arc]
getHeadArc (Node (Step index category headArc depArcs : _) _) = headArc

</pre>
</div>


<p>
To extract list of left-dependent arcs from node
</p>

<div class="org-src-container">
<pre class="src src-haskell">
getDepArcs :: Node -&gt; [Arc]
getDepArcs (Node (Step index category headArc depArcs : _) _) = depArcs

</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc93297" class="outline-3">
<h3 id="orgbc93297"><span class="section-number-3">8.2</span> Extracting Neighbouring Nodes From Node</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Finally&#x2026; the most essential property of a node value is that it 'contains'
the current state of the tree within it - that is, all the other nodes from the partial parse it
belongs to can be accessed from it.
</p>

<p>
To access the immediately preceding and succeeding (left and right neighbour) nodes:
</p>

<div class="org-src-container">
<pre class="src src-haskell">
leftNeighbour, rightNeighbour :: Node -&gt; [Node]
leftNeighbour (Node (s : s' : p) q) = [Node (s' : p) (s : q)]
leftNeighbour _ = []
rightNeighbour (Node p (s : q)) = [Node (s : p) q]
rightNeighbour _ = []

</pre>
</div>

<p>
To access all the predecessors and successors of a node, we compute the closure
of the left/right neighbours of the node.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
preds, succs :: Node -&gt; [Node]
preds = clo leftNeighbour
succs = clo rightNeighbour

</pre>
</div>
</div>
</div>

<div id="outline-container-orgcc88829" class="outline-3">
<h3 id="orgcc88829"><span class="section-number-3">8.3</span> Extracting Head And Dependents Of Node</h3>
<div class="outline-text-3" id="text-8-3">
<p>
The following functions are helper functions that compute the left and right
dependents of a node.
</p>

<p>
The function <code>leftDepHelper</code> computes the left dependents of a node by
selecting elements from the list of predecessors of a node, for which there
exists a dependency arc with index equal to index of the node. <code>rightDepHelper</code>
similarly computes the list of right dependents from the list of successors of
the node, whose left head's index is equal to that of the node (Remember here
that we only store left heads and left dependencies). The functions
<code>leftHeadHelper</code> and <code>rightHeadHelper</code> are implemented analogously.
</p>

<p>
The total list of heads and dependencies of a node is computed by combining the
lists for left and right heads/dependencies.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
-- argNode : argument Node

leftDepHelper, rightDepHelper, depHelper :: Node -&gt;  [(Role, Node)]
leftDepHelper argNode = [(role, node) | node &lt;- preds argNode,
                          (role, index) &lt;- getDepArcs argNode,
                         (getIndex node) == index]
rightDepHelper argNode = [(role, node) | node &lt;- succs argNode,
                          (role, index) &lt;- getHeadArc node,
                          (getIndex argNode) == index]
depHelper = leftDepHelper `mappend` rightDepHelper


leftHeadHelper, rightHeadHelper, headHelper :: Node -&gt; [(Role, Node)]
leftHeadHelper argNode = [(role, node) | node &lt;- preds argNode,
                          (role, index) &lt;- getHeadArc argNode,
                          (getIndex node) == index]
rightHeadHelper argNode = [(role, node) | node &lt;- succs argNode,
                           (role, index) &lt;- getDepArcs node,
                           (getIndex argNode) == index]
headHelper = leftHeadHelper `mappend` rightHeadHelper

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org8f72b1c" class="outline-2">
<h2 id="org8f72b1c"><span class="section-number-2">9</span> Higher-Level Interface Functions</h2>
<div class="outline-text-2" id="text-9">
<p>
The functions defined above are not meant to be used directly by
grammar writers. They form the base ("under the hood", so to speak) of the set
of basic parser interface functions, that are directly used in the construction
of a grammar.
</p>
</div>

<div id="outline-container-orga5333f8" class="outline-3">
<h3 id="orga5333f8"><span class="section-number-3">9.1</span> For Computing Related Nodes</h3>
<div class="outline-text-3" id="text-9-1">
<p>
The following functions return groups of related nodes, related by
dependent/head relation.
</p>

<div class="org-src-container">
<pre class="src src-haskell">

leftDep, rightDep, dep, leftHead, rightHead, parseHead :: Node -&gt; [Node]
leftDep   = fmap snd . leftDepHelper
rightDep  = fmap snd . rightDepHelper
dep       = fmap snd . depHelper
leftHead  = fmap snd . leftHeadHelper
rightHead = fmap snd . rightHeadHelper
parseHead = fmap snd . headHelper

</pre>
</div>
</div>
</div>

<div id="outline-container-orgbdcf198" class="outline-3">
<h3 id="orgbdcf198"><span class="section-number-3">9.2</span> For Computing Arc Roles</h3>
<div class="outline-text-3" id="text-9-2">
<p>
The following is the set of functions for computing roles of in-going and
out-going arcs.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
leftDepRoles, rightDepRoles, depRoles, leftHeadRoles, rightHeadRoles, headRoles :: Node -&gt; [Role]
leftDepRoles   = fmap fst . leftDepHelper
rightDepRoles  = fmap fst . rightDepHelper
depRoles       = fmap fst . depHelper
leftHeadRoles  = fmap fst . leftHeadHelper
rightHeadRoles = fmap fst . rightHeadHelper
headRoles      = fmap fst . headHelper


</pre>
</div>
</div>
</div>
<div id="outline-container-org8accf9b" class="outline-3">
<h3 id="org8accf9b"><span class="section-number-3">9.3</span> For Finding Relations of a Specific Type</h3>
<div class="outline-text-3" id="text-9-3">
<p>
The following is the set of functions used to find all dependents of a specific
type.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
leftDepBy, rightDepBy, depBy :: Role -&gt; Node -&gt; [Node]
leftDepBy argRole argNode  = [ node | (argRole, node) &lt;- leftDepHelper argNode ]
rightDepBy argRole argNode = [ node | (argRole, node) &lt;- rightDepHelper argNode]
depBy argRole = leftDepBy argRole `mappend` rightDepBy argRole


leftHeadBy, rightHeadBy, headBy :: Role -&gt; Node -&gt; [Node]
leftHeadBy argRole argNode  = [ node | (argRole, node) &lt;- leftHeadHelper argNode ] 
rightHeadBy argRole argNode = [ node | (argRole, node) &lt;- rightHeadHelper argNode]
headBy argRole = leftHeadBy argRole `mappend` rightHeadBy argRole

</pre>
</div>
</div>
</div>

<div id="outline-container-org22b787c" class="outline-3">
<h3 id="org22b787c"><span class="section-number-3">9.4</span> Other Useful Functions</h3>
<div class="outline-text-3" id="text-9-4">
<p>
The following are functions to compute the leftmost and rightmost nodes.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
leftmost, rightmost :: [Node] -&gt; [Node]
leftmost [] = []
leftmost xs = [minimum xs]
rightmost [] = []
rightmost xs = [minimum xs]

</pre>
</div>

<p>
We also write a function for checking whether an argument node has no head
(assuming the grammar does not allow for forests, this would check for root
node), and to find the last node of a parse (i.e: the node containing the final
parse.)
</p>

<div class="org-src-container">
<pre class="src src-haskell">
headless :: Node -&gt; Bool
headless = null . parseHead


lastNode :: Parse -&gt; Node
lastNode p = Node p []

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgad4828c" class="outline-2">
<h2 id="orgad4828c"><span class="section-number-2">10</span> Parser Core</h2>
<div class="outline-text-2" id="text-10">
<p>
After defining the data structures and interface functions, we construct the
core of the parser engine.
</p>

<p>
First, we define what a word is.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
type ParseWord = String

</pre>
</div>

<p>
The computation of a parse is carried out by the <code>step</code> function, which takes a
(partial) parse and a word, and computes the next <code>Step</code>. This function can be
decomposed into two independent operations: 
</p>

<ul class="org-ul">
<li><code>shift</code> : add a new <code>Step</code> with only the word's category and index, and no
connections formerd</li>
<li><code>connect</code> : create dependency connections for the new node.</li>
</ul>
</div>


<div id="outline-container-org5246c33" class="outline-3">
<h3 id="org5246c33"><span class="section-number-3">10.1</span> Shift Function</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Here, <code>dic</code> is a function that's assumed to be provided by the external
lexicon, that takes a word as input and returns a list of its syntactic
categories.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
shift :: ParseWord -&gt; Parse -&gt; [Parse]
shift word parse = [ parse &lt;&lt; (nextId parse, cat) | cat &lt;- dic word ]
                   where
                     nextId [] = 1
                     nextId (Step index category headArc depArcs : _) = index + 1

</pre>
</div>
</div>
</div>

<div id="outline-container-orgf236185" class="outline-3">
<h3 id="orgf236185"><span class="section-number-3">10.2</span> Helper Functions for Connect</h3>
<div class="outline-text-3" id="text-10-2">
<p>
For the implementation of the <code>connect</code> function, we define two helper
functions :
</p>

<ul class="org-ul">
<li><code>addHead</code> : if the current node has no head attached, finds a head for the
current node and attaches current node as dependent</li>
<li><code>addDep</code>  : finds potential dependents of the current node, and if they
have no head attaches, attaches the current node as their head</li>
</ul>

<p>
For the implementation of the above two functions, we assume a lexicon that
provides two helper functions <code>heads</code> and <code>deps</code>, that return a list of
potential head nodes and potential dependent nodes, respectively.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
addHead, addDep :: Parse -&gt; [Parse]
addHead parse = [ parse +-&gt; (role, getIndex node) | let currentNode = lastNode parse,
                                                    headless currentNode,
                                                    (role, node) &lt;- heads currentNode]
addDep parse  = [ parse +&lt;-(role, getIndex node) | let currentNode = lastNode parse,
                                                   (role, node) &lt;- deps currentNode,
                                                   headless node] 

</pre>
</div>
</div>
</div>
<div id="outline-container-orgfbe3dac" class="outline-3">
<h3 id="orgfbe3dac"><span class="section-number-3">10.3</span> Connect Function</h3>
<div class="outline-text-3" id="text-10-3">
<p>
The <code>connect</code> function combines parses returns parses returned by <code>addHead</code>,
<code>addDep</code>, and the unchanged parse (returned by <code>pure</code>) and returns a combined
list of parses.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
connect :: Parse -&gt; [Parse]
connect = (addDep &gt;=&gt; connect) `mappend` addHead `mappend` pure

</pre>
</div>
</div>
</div>

<div id="outline-container-orgd813f34" class="outline-3">
<h3 id="orgd813f34"><span class="section-number-3">10.4</span> Step function</h3>
<div class="outline-text-3" id="text-10-4">
<p>
Now the <code>step</code> operation is implemented by combining <code>shift</code> and <code>connect</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell">
step :: ParseWord -&gt; Parse -&gt; [Parse]
step word = shift word &gt;=&gt; connect


</pre>
</div>
</div>
</div>
<div id="outline-container-org1c173f7" class="outline-3">
<h3 id="org1c173f7"><span class="section-number-3">10.5</span> <code>steps</code> and <code>parser</code> functions</h3>
<div class="outline-text-3" id="text-10-5">
<div class="org-src-container">
<pre class="src src-haskell">
steps :: [ParseWord] -&gt; [Parse]
steps = foldM (flip step) []

parser :: [ParseWord] -&gt; [Parse]
parser = filter (pass . lastNode) . steps

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Atreyee</p>
<p class="date">Created: 2017-06-29 Thu 15:01</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
