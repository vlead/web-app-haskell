#+TITLE: Building Systems in Haskell - Advantages and Disadvantages


The aim of this paper is to enumerate the advantages and disadvantages of
building a system in Haskell.

We illustrate the above by comparing the implementations of a set of
requirements in two languages - Python and Haskell.

The type of system being considered here is a Web Application, that stores a
set of objects and performs CRUD operations on those objects.

* The Requirements


The requirements are - to build a web application that has persistence of data,
performs CRUD operations on the data,
and interacts with the user via a REST API. The full description of
requirements is given [[file:.Req.org][here.]]

The given implementation does not feature deployment or a frontend.

* Why Haskell

Popular languages for building web applications- Python, Javascript, etc - have the
following features:

  - Dynamic typing, and therefore the absence of type-checks
  - Primarily object-oriented (Python supports a number of paradigms through
    libraries, but is primarily an object-oriented language)
  - Imperative

Haskell, on the other hand, has the following features:

  - Static typing- typechecks done on compilation
  - Pure functional
  - Declarative
  - Supports a complex and robust type system, which is not seen in the above
    languages
* Comparision

This section compares aspects of the implementations in Python and in Haskell.

** Program Length

A crude measure of the size of the final software is non-whitespace non-comment
lines of code.

LOC for Haskell program: 1,205
LOC for Python program: 4,802

The final size of code of the Haskell program is one-fourth the size of the
Python program, thus suggesting that Haskell is a more concise and expressive
language (Same set of requirements expressed in lesser size of code.)

Code size for the core implementation- excluding test case files- is:

Haskell program: 
** Modularisability

For building industrial-standard code, modularisability is
essential. Well-structured, modularised code ensures:

  1) Easy extending and refactoring
  2) Adheres to the Microservices framework
  3) Easy maintenance and bug testing (ability to localise bugs to one module
     of code)

*** Haskell Support for Modules

The =Stack= build system in Haskell has inbuilt support for modules.

*** Modularisation 

** Cyclomatic Complexity??

*is it a good measure of complexity of code?*
*technically it is, because it measures the complexity of code, that measures*
*how easy it is to maintain and refactor*
