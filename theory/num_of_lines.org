#+TITLE: Notes For Comparision Study
#+AUTHOR: Atreyee Ghosal


The aim of this paper is to compare two implementations of the same set of
requirements- one written in Haskell, and another written in Python.

* The Requirements

The requirements are - to build a web application that has persistence of data
and interacts with the user via a REST API. The full description of
requirements is given [[file:.Req.org][here.]]

The given implementation does not feature deployment or a frontend.

* Why Haskell And Python

The two languages are chosen to compare based on the following features:

  - Python is a dynamic-typed language, while Haskell is a static-typed
    language
  - Python supports a number of paradigms, but primarily employs
    object-oriented architecture. Haskell is a pure functional language
  - Haskell supports a complex and robust type system, that is not seen in
    Python

* What Are We Comparing?

The metrics chosen for comparison are the following:

** Program Length

Program length is measured by Lines of Code.

** Modularisation

Modularisability of the Haskell program versus modularisability of the Python
program.
** Checks Made Redundant By Types

On the checks run on the Python program versus those run on the Haskell
program, it is compared as to how many of those checks are made redundant due
to the type system of Haskell.

* Program Length

  - Python : 4,802
  - Haskell : 1,205

* Modularisability

** Different Ways The Two Programs Are Modularised

*** Python

The Python code is divided into the following components:

  - Config 
  - Exceptions 
  - Objects
  - Persistence
  - REST
  - System
  - Utils

With each component having a dedicated test suite.

*** Haskell

The Haskell code is divided into the following components:

  - App 
  - 
** The IO Monads and Modularisability

Haskell wraps "impure" actions- actions that lead to state change within the
system - within a construct called a "monad".

Input/output actions are wrapped within the IO monad, meaning that any action
performed on an input/output value must be wrapped within the monad.

This makes modularisation clunky, as IO data cannot be passed around the system
freely- all manipulations on IO data must be done within the same monad.

Therefore, Haskell code suffers in terms of modularisability w.r.t components. 

In this implementation, we have chosen to modularise the code in terms of
functionality- dividing it into functional units.

* Other Comparision
  
** Type-Safety

The python program employs predicate checks to ensure that input/output data,
as well as data passed within the program, is correctly formed.

Haskell abstracts out the notion of predicate checks via the type system.
** Documentation

Haskell libraries are poorly documented compared to Python's.
* Confounding Factors

It must be noted that in this comparison, confounding factors have not been
accounted for:

  1) Programmer-related factors
  2) Library-related factors: i.e. the observed results may be in large part
     due to the libraries used
  3) Differences between different implementations within the same language may
     be more significant than differences between implementations in different languages
